package org.jboss.tusk.monitoring;

import java.io.IOException;
import java.io.Serializable;
import java.util.Collection;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Session;

import org.jboss.ejb3.annotation.Depends;
import org.jboss.ejb3.annotation.Management;
import org.jboss.ejb3.annotation.Service;
import org.jboss.tusk.jms.utility.MessageStubUtility;

/**
 * The BigDataMessengerManagementBean is one of several ways to send information into the Tusk Application.  The
 * class is used solely as a testing mechanism, and pushes one to many stubbed out messages into the application 
 * via the ESB.  This class exposes two (2) stubMessages operations that generate the test message by making use
 * of The MessageStubUtility class.
 * 
 * The messages generated by this bean are delivered to the DocumentEntry queue.  The DocumentEntry service
 * is configured to listen on this queue.
 * 
 * @author
 *
 */
@Service()
@Management(BigDataMessengerManagement.class)
//@Depends({"com.jboss.bigdata:name=DocumentEntry,service=Queue"}) //this one is for JBM
@Depends({"org.hornetq:module=JMS,type=Queue,name=\"DocumentEntry\""}) //this one is for HornetQ
public class BigDataMessengerManagementBean implements BigDataMessengerManagement {

	@Resource(mappedName="java:/JmsXA") ConnectionFactory factory;
	@Resource(mappedName="queue/DocumentEntry") Destination documentQueue;
	
	private final MessageStubUtility msu;
	
	public BigDataMessengerManagementBean() throws IOException {
		msu = new MessageStubUtility();
	}
	
	/**
	 * This allows the caller to specify how many XML messages to send to Tusk.  
	 * This operation is also responsible for passing the messages one by one to be delivered to
	 * the ESB.
	 * 
	 * @param count
	 */
	public void stubXmlMessages(int count) {
		Collection<String> messages = msu.stubXmlMessages(count);
		for(String msg : messages) {
			sendObject(msg);
		}
	}

	/**
	 * This generates 10 XML messages to send to Tusk.
	 */
	public void stubXmlMessages() {
		stubXmlMessages(10);
	}
	
	/**
	 * This allows the caller to specify how many JSON messages to send to Tusk.  
	 * This operation is also responsible for passing the messages one by one to be delivered to
	 * the ESB.
	 * 
	 * @param count
	 */
	public void stubJsonMessages(int count) {
		Collection<String> messages = msu.stubJsonMessages(count);
		for(String msg : messages) {
			sendObject(msg);
		}
	}

	/**
	 * This generates 10 JSON messages to send to Tusk.
	 */
	public void stubJsonMessages() {
		stubJsonMessages(10);
	}
	
	/**
	 * The handles the delivery of messages to the ESB via the
	 * DocumentEntry queue.  Tusk's DocumentEntry service is listening on this queue and
	 * accepts the messages for processing.
	 * 
	 * @param o
	 */
	private void sendObject(Serializable o) {
		javax.jms.Connection connection = null;
		Session session = null;
		MessageProducer producer = null;
		
		try {
			connection = factory.createConnection();
			session = connection.createSession(true, Session.SESSION_TRANSACTED);
			
			ObjectMessage om = session.createObjectMessage();
			om.setObject(o);
			
			producer = session.createProducer(documentQueue);
			producer.send(om);
		
		} catch (JMSException e) {
			e.printStackTrace();
		} finally {
			if(producer!=null){try {producer.close();} catch(Exception e){};}
			if(session!=null){try {session.close();} catch(Exception e){};}
			if(connection!=null){try {connection.close();} catch(Exception e){};}
		}
	}
}